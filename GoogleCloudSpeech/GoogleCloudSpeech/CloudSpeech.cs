// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cloudSpeechBeta/cloud_speech.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Speech.V1Beta1 {

  /// <summary>Holder for reflection information generated from cloudSpeechBeta/cloud_speech.proto</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class CloudSpeechReflection {

    #region Descriptor
    /// <summary>File descriptor for cloudSpeechBeta/cloud_speech.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CloudSpeechReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiJjbG91ZFNwZWVjaEJldGEvY2xvdWRfc3BlZWNoLnByb3RvEhtnb29nbGUu",
            "Y2xvdWQuc3BlZWNoLnYxYmV0YTEaEWFubm90YXRpb25zLnByb3RvGhBvcGVy",
            "YXRpb25zLnByb3RvGgxzdGF0dXMucHJvdG8ilAEKFFN5bmNSZWNvZ25pemVS",
            "ZXF1ZXN0Ej4KBmNvbmZpZxgBIAEoCzIuLmdvb2dsZS5jbG91ZC5zcGVlY2gu",
            "djFiZXRhMS5SZWNvZ25pdGlvbkNvbmZpZxI8CgVhdWRpbxgCIAEoCzItLmdv",
            "b2dsZS5jbG91ZC5zcGVlY2gudjFiZXRhMS5SZWNvZ25pdGlvbkF1ZGlvIpUB",
            "ChVBc3luY1JlY29nbml6ZVJlcXVlc3QSPgoGY29uZmlnGAEgASgLMi4uZ29v",
            "Z2xlLmNsb3VkLnNwZWVjaC52MWJldGExLlJlY29nbml0aW9uQ29uZmlnEjwK",
            "BWF1ZGlvGAIgASgLMi0uZ29vZ2xlLmNsb3VkLnNwZWVjaC52MWJldGExLlJl",
            "Y29nbml0aW9uQXVkaW8ingEKGVN0cmVhbWluZ1JlY29nbml6ZVJlcXVlc3QS",
            "UwoQc3RyZWFtaW5nX2NvbmZpZxgBIAEoCzI3Lmdvb2dsZS5jbG91ZC5zcGVl",
            "Y2gudjFiZXRhMS5TdHJlYW1pbmdSZWNvZ25pdGlvbkNvbmZpZ0gAEhcKDWF1",
            "ZGlvX2NvbnRlbnQYAiABKAxIAEITChFzdHJlYW1pbmdfcmVxdWVzdCKPAQoa",
            "U3RyZWFtaW5nUmVjb2duaXRpb25Db25maWcSPgoGY29uZmlnGAEgASgLMi4u",
            "Z29vZ2xlLmNsb3VkLnNwZWVjaC52MWJldGExLlJlY29nbml0aW9uQ29uZmln",
            "EhgKEHNpbmdsZV91dHRlcmFuY2UYAiABKAgSFwoPaW50ZXJpbV9yZXN1bHRz",
            "GAMgASgIIuoCChFSZWNvZ25pdGlvbkNvbmZpZxJOCghlbmNvZGluZxgBIAEo",
            "DjI8Lmdvb2dsZS5jbG91ZC5zcGVlY2gudjFiZXRhMS5SZWNvZ25pdGlvbkNv",
            "bmZpZy5BdWRpb0VuY29kaW5nEhMKC3NhbXBsZV9yYXRlGAIgASgFEhUKDWxh",
            "bmd1YWdlX2NvZGUYAyABKAkSGAoQbWF4X2FsdGVybmF0aXZlcxgEIAEoBRIY",
            "ChBwcm9mYW5pdHlfZmlsdGVyGAUgASgIEkIKDnNwZWVjaF9jb250ZXh0GAYg",
            "ASgLMiouZ29vZ2xlLmNsb3VkLnNwZWVjaC52MWJldGExLlNwZWVjaENvbnRl",
            "eHQiYQoNQXVkaW9FbmNvZGluZxIYChRFTkNPRElOR19VTlNQRUNJRklFRBAA",
            "EgwKCExJTkVBUjE2EAESCAoERkxBQxACEgkKBU1VTEFXEAMSBwoDQU1SEAQS",
            "CgoGQU1SX1dCEAUiIAoNU3BlZWNoQ29udGV4dBIPCgdwaHJhc2VzGAEgAygJ",
            "IkQKEFJlY29nbml0aW9uQXVkaW8SEQoHY29udGVudBgBIAEoDEgAEg0KA3Vy",
            "aRgCIAEoCUgAQg4KDGF1ZGlvX3NvdXJjZSJeChVTeW5jUmVjb2duaXplUmVz",
            "cG9uc2USRQoHcmVzdWx0cxgCIAMoCzI0Lmdvb2dsZS5jbG91ZC5zcGVlY2gu",
            "djFiZXRhMS5TcGVlY2hSZWNvZ25pdGlvblJlc3VsdCJfChZBc3luY1JlY29n",
            "bml6ZVJlc3BvbnNlEkUKB3Jlc3VsdHMYAiADKAsyNC5nb29nbGUuY2xvdWQu",
            "c3BlZWNoLnYxYmV0YTEuU3BlZWNoUmVjb2duaXRpb25SZXN1bHQihQMKGlN0",
            "cmVhbWluZ1JlY29nbml6ZVJlc3BvbnNlEiEKBWVycm9yGAEgASgLMhIuZ29v",
            "Z2xlLnJwYy5TdGF0dXMSSAoHcmVzdWx0cxgCIAMoCzI3Lmdvb2dsZS5jbG91",
            "ZC5zcGVlY2gudjFiZXRhMS5TdHJlYW1pbmdSZWNvZ25pdGlvblJlc3VsdBIU",
            "CgxyZXN1bHRfaW5kZXgYAyABKAUSXwoPZW5kcG9pbnRlcl90eXBlGAQgASgO",
            "MkYuZ29vZ2xlLmNsb3VkLnNwZWVjaC52MWJldGExLlN0cmVhbWluZ1JlY29n",
            "bml6ZVJlc3BvbnNlLkVuZHBvaW50ZXJUeXBlIoIBCg5FbmRwb2ludGVyVHlw",
            "ZRIgChxFTkRQT0lOVEVSX0VWRU5UX1VOU1BFQ0lGSUVEEAASEwoPU1RBUlRf",
            "T0ZfU1BFRUNIEAESEQoNRU5EX09GX1NQRUVDSBACEhAKDEVORF9PRl9BVURJ",
            "TxADEhQKEEVORF9PRl9VVFRFUkFOQ0UQBCKSAQoaU3RyZWFtaW5nUmVjb2du",
            "aXRpb25SZXN1bHQSTwoMYWx0ZXJuYXRpdmVzGAEgAygLMjkuZ29vZ2xlLmNs",
            "b3VkLnNwZWVjaC52MWJldGExLlNwZWVjaFJlY29nbml0aW9uQWx0ZXJuYXRp",
            "dmUSEAoIaXNfZmluYWwYAiABKAgSEQoJc3RhYmlsaXR5GAMgASgCImoKF1Nw",
            "ZWVjaFJlY29nbml0aW9uUmVzdWx0Ek8KDGFsdGVybmF0aXZlcxgBIAMoCzI5",
            "Lmdvb2dsZS5jbG91ZC5zcGVlY2gudjFiZXRhMS5TcGVlY2hSZWNvZ25pdGlv",
            "bkFsdGVybmF0aXZlIkYKHFNwZWVjaFJlY29nbml0aW9uQWx0ZXJuYXRpdmUS",
            "EgoKdHJhbnNjcmlwdBgBIAEoCRISCgpjb25maWRlbmNlGAIgASgCMsgDCgZT",
            "cGVlY2gSoAEKDVN5bmNSZWNvZ25pemUSMS5nb29nbGUuY2xvdWQuc3BlZWNo",
            "LnYxYmV0YTEuU3luY1JlY29nbml6ZVJlcXVlc3QaMi5nb29nbGUuY2xvdWQu",
            "c3BlZWNoLnYxYmV0YTEuU3luY1JlY29nbml6ZVJlc3BvbnNlIiiC0+STAiIi",
            "HS92MWJldGExL3NwZWVjaDpzeW5jcmVjb2duaXplOgEqEo4BCg5Bc3luY1Jl",
            "Y29nbml6ZRIyLmdvb2dsZS5jbG91ZC5zcGVlY2gudjFiZXRhMS5Bc3luY1Jl",
            "Y29nbml6ZVJlcXVlc3QaHS5nb29nbGUubG9uZ3J1bm5pbmcuT3BlcmF0aW9u",
            "IimC0+STAiMiHi92MWJldGExL3NwZWVjaDphc3luY3JlY29nbml6ZToBKhKJ",
            "AQoSU3RyZWFtaW5nUmVjb2duaXplEjYuZ29vZ2xlLmNsb3VkLnNwZWVjaC52",
            "MWJldGExLlN0cmVhbWluZ1JlY29nbml6ZVJlcXVlc3QaNy5nb29nbGUuY2xv",
            "dWQuc3BlZWNoLnYxYmV0YTEuU3RyZWFtaW5nUmVjb2duaXplUmVzcG9uc2Uo",
            "ATABQjAKH2NvbS5nb29nbGUuY2xvdWQuc3BlZWNoLnYxYmV0YTFCC1NwZWVj",
            "aFByb3RvUAFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Longrunning.OperationsReflection.Descriptor, global::Google.Rpc.StatusReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Speech.V1Beta1.SyncRecognizeRequest), global::Google.Cloud.Speech.V1Beta1.SyncRecognizeRequest.Parser, new[]{ "Config", "Audio" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Speech.V1Beta1.AsyncRecognizeRequest), global::Google.Cloud.Speech.V1Beta1.AsyncRecognizeRequest.Parser, new[]{ "Config", "Audio" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Speech.V1Beta1.StreamingRecognizeRequest), global::Google.Cloud.Speech.V1Beta1.StreamingRecognizeRequest.Parser, new[]{ "StreamingConfig", "AudioContent" }, new[]{ "StreamingRequest" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Speech.V1Beta1.StreamingRecognitionConfig), global::Google.Cloud.Speech.V1Beta1.StreamingRecognitionConfig.Parser, new[]{ "Config", "SingleUtterance", "InterimResults" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Speech.V1Beta1.RecognitionConfig), global::Google.Cloud.Speech.V1Beta1.RecognitionConfig.Parser, new[]{ "Encoding", "SampleRate", "LanguageCode", "MaxAlternatives", "ProfanityFilter", "SpeechContext" }, null, new[]{ typeof(global::Google.Cloud.Speech.V1Beta1.RecognitionConfig.Types.AudioEncoding) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Speech.V1Beta1.SpeechContext), global::Google.Cloud.Speech.V1Beta1.SpeechContext.Parser, new[]{ "Phrases" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Speech.V1Beta1.RecognitionAudio), global::Google.Cloud.Speech.V1Beta1.RecognitionAudio.Parser, new[]{ "Content", "Uri" }, new[]{ "AudioSource" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Speech.V1Beta1.SyncRecognizeResponse), global::Google.Cloud.Speech.V1Beta1.SyncRecognizeResponse.Parser, new[]{ "Results" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Speech.V1Beta1.AsyncRecognizeResponse), global::Google.Cloud.Speech.V1Beta1.AsyncRecognizeResponse.Parser, new[]{ "Results" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Speech.V1Beta1.StreamingRecognizeResponse), global::Google.Cloud.Speech.V1Beta1.StreamingRecognizeResponse.Parser, new[]{ "Error", "Results", "ResultIndex", "EndpointerType" }, null, new[]{ typeof(global::Google.Cloud.Speech.V1Beta1.StreamingRecognizeResponse.Types.EndpointerType) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Speech.V1Beta1.StreamingRecognitionResult), global::Google.Cloud.Speech.V1Beta1.StreamingRecognitionResult.Parser, new[]{ "Alternatives", "IsFinal", "Stability" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionResult), global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionResult.Parser, new[]{ "Alternatives" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionAlternative), global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionAlternative.Parser, new[]{ "Transcript", "Confidence" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///  `SyncRecognizeRequest` is the top-level message sent by the client for
  ///  the `SyncRecognize` method.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class SyncRecognizeRequest : pb::IMessage<SyncRecognizeRequest> {
    private static readonly pb::MessageParser<SyncRecognizeRequest> _parser = new pb::MessageParser<SyncRecognizeRequest>(() => new SyncRecognizeRequest());
    public static pb::MessageParser<SyncRecognizeRequest> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Speech.V1Beta1.CloudSpeechReflection.Descriptor.MessageTypes[0]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public SyncRecognizeRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    public SyncRecognizeRequest(SyncRecognizeRequest other) : this() {
      Config = other.config_ != null ? other.Config.Clone() : null;
      Audio = other.audio_ != null ? other.Audio.Clone() : null;
    }

    public SyncRecognizeRequest Clone() {
      return new SyncRecognizeRequest(this);
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 1;
    private global::Google.Cloud.Speech.V1Beta1.RecognitionConfig config_;
    /// <summary>
    ///  [Required] The `config` message provides information to the recognizer
    ///  that specifies how to process the request.
    /// </summary>
    public global::Google.Cloud.Speech.V1Beta1.RecognitionConfig Config {
      get { return config_; }
      set {
        config_ = value;
      }
    }

    /// <summary>Field number for the "audio" field.</summary>
    public const int AudioFieldNumber = 2;
    private global::Google.Cloud.Speech.V1Beta1.RecognitionAudio audio_;
    /// <summary>
    ///  [Required] The audio data to be recognized.
    /// </summary>
    public global::Google.Cloud.Speech.V1Beta1.RecognitionAudio Audio {
      get { return audio_; }
      set {
        audio_ = value;
      }
    }

    public override bool Equals(object other) {
      return Equals(other as SyncRecognizeRequest);
    }

    public bool Equals(SyncRecognizeRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Config, other.Config)) return false;
      if (!object.Equals(Audio, other.Audio)) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (config_ != null) hash ^= Config.GetHashCode();
      if (audio_ != null) hash ^= Audio.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (config_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Config);
      }
      if (audio_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Audio);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (config_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      if (audio_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Audio);
      }
      return size;
    }

    public void MergeFrom(SyncRecognizeRequest other) {
      if (other == null) {
        return;
      }
      if (other.config_ != null) {
        if (config_ == null) {
          config_ = new global::Google.Cloud.Speech.V1Beta1.RecognitionConfig();
        }
        Config.MergeFrom(other.Config);
      }
      if (other.audio_ != null) {
        if (audio_ == null) {
          audio_ = new global::Google.Cloud.Speech.V1Beta1.RecognitionAudio();
        }
        Audio.MergeFrom(other.Audio);
      }
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (config_ == null) {
              config_ = new global::Google.Cloud.Speech.V1Beta1.RecognitionConfig();
            }
            input.ReadMessage(config_);
            break;
          }
          case 18: {
            if (audio_ == null) {
              audio_ = new global::Google.Cloud.Speech.V1Beta1.RecognitionAudio();
            }
            input.ReadMessage(audio_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  `AsyncRecognizeRequest` is the top-level message sent by the client for
  ///  the `AsyncRecognize` method.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class AsyncRecognizeRequest : pb::IMessage<AsyncRecognizeRequest> {
    private static readonly pb::MessageParser<AsyncRecognizeRequest> _parser = new pb::MessageParser<AsyncRecognizeRequest>(() => new AsyncRecognizeRequest());
    public static pb::MessageParser<AsyncRecognizeRequest> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Speech.V1Beta1.CloudSpeechReflection.Descriptor.MessageTypes[1]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public AsyncRecognizeRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    public AsyncRecognizeRequest(AsyncRecognizeRequest other) : this() {
      Config = other.config_ != null ? other.Config.Clone() : null;
      Audio = other.audio_ != null ? other.Audio.Clone() : null;
    }

    public AsyncRecognizeRequest Clone() {
      return new AsyncRecognizeRequest(this);
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 1;
    private global::Google.Cloud.Speech.V1Beta1.RecognitionConfig config_;
    /// <summary>
    ///  [Required] The `config` message provides information to the recognizer
    ///  that specifies how to process the request.
    /// </summary>
    public global::Google.Cloud.Speech.V1Beta1.RecognitionConfig Config {
      get { return config_; }
      set {
        config_ = value;
      }
    }

    /// <summary>Field number for the "audio" field.</summary>
    public const int AudioFieldNumber = 2;
    private global::Google.Cloud.Speech.V1Beta1.RecognitionAudio audio_;
    /// <summary>
    ///  [Required] The audio data to be recognized.
    /// </summary>
    public global::Google.Cloud.Speech.V1Beta1.RecognitionAudio Audio {
      get { return audio_; }
      set {
        audio_ = value;
      }
    }

    public override bool Equals(object other) {
      return Equals(other as AsyncRecognizeRequest);
    }

    public bool Equals(AsyncRecognizeRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Config, other.Config)) return false;
      if (!object.Equals(Audio, other.Audio)) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (config_ != null) hash ^= Config.GetHashCode();
      if (audio_ != null) hash ^= Audio.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (config_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Config);
      }
      if (audio_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Audio);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (config_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      if (audio_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Audio);
      }
      return size;
    }

    public void MergeFrom(AsyncRecognizeRequest other) {
      if (other == null) {
        return;
      }
      if (other.config_ != null) {
        if (config_ == null) {
          config_ = new global::Google.Cloud.Speech.V1Beta1.RecognitionConfig();
        }
        Config.MergeFrom(other.Config);
      }
      if (other.audio_ != null) {
        if (audio_ == null) {
          audio_ = new global::Google.Cloud.Speech.V1Beta1.RecognitionAudio();
        }
        Audio.MergeFrom(other.Audio);
      }
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (config_ == null) {
              config_ = new global::Google.Cloud.Speech.V1Beta1.RecognitionConfig();
            }
            input.ReadMessage(config_);
            break;
          }
          case 18: {
            if (audio_ == null) {
              audio_ = new global::Google.Cloud.Speech.V1Beta1.RecognitionAudio();
            }
            input.ReadMessage(audio_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  `StreamingRecognizeRequest` is the top-level message sent by the client for
  ///  the `StreamingRecognize`. Multiple `StreamingRecognizeRequest` messages are
  ///  sent. The first message must contain a `streaming_config` message and must
  ///  not contain `audio` data. All subsequent messages must contain `audio` data
  ///  and must not contain a `streaming_config` message.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class StreamingRecognizeRequest : pb::IMessage<StreamingRecognizeRequest> {
    private static readonly pb::MessageParser<StreamingRecognizeRequest> _parser = new pb::MessageParser<StreamingRecognizeRequest>(() => new StreamingRecognizeRequest());
    public static pb::MessageParser<StreamingRecognizeRequest> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Speech.V1Beta1.CloudSpeechReflection.Descriptor.MessageTypes[2]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public StreamingRecognizeRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    public StreamingRecognizeRequest(StreamingRecognizeRequest other) : this() {
      switch (other.StreamingRequestCase) {
        case StreamingRequestOneofCase.StreamingConfig:
          StreamingConfig = other.StreamingConfig.Clone();
          break;
        case StreamingRequestOneofCase.AudioContent:
          AudioContent = other.AudioContent;
          break;
      }

    }

    public StreamingRecognizeRequest Clone() {
      return new StreamingRecognizeRequest(this);
    }

    /// <summary>Field number for the "streaming_config" field.</summary>
    public const int StreamingConfigFieldNumber = 1;
    /// <summary>
    ///  The `streaming_config` message provides information to the recognizer
    ///  that specifies how to process the request.
    ///
    ///  The first `StreamingRecognizeRequest` message must contain a
    ///  `streaming_config`  message.
    /// </summary>
    public global::Google.Cloud.Speech.V1Beta1.StreamingRecognitionConfig StreamingConfig {
      get { return streamingRequestCase_ == StreamingRequestOneofCase.StreamingConfig ? (global::Google.Cloud.Speech.V1Beta1.StreamingRecognitionConfig) streamingRequest_ : null; }
      set {
        streamingRequest_ = value;
        streamingRequestCase_ = value == null ? StreamingRequestOneofCase.None : StreamingRequestOneofCase.StreamingConfig;
      }
    }

    /// <summary>Field number for the "audio_content" field.</summary>
    public const int AudioContentFieldNumber = 2;
    /// <summary>
    ///  The audio data to be recognized. Sequential chunks of audio data are sent
    ///  in sequential `StreamingRecognizeRequest` messages. The first
    ///  `StreamingRecognizeRequest` message must not contain `audio_content` data
    ///  and all subsequent `StreamingRecognizeRequest` messages must contain
    ///  `audio_content` data. The audio bytes must be encoded as specified in
    ///  `RecognitionConfig`. Note: as with all bytes fields, protobuffers use a
    ///  pure binary representation (not base64).
    /// </summary>
    public pb::ByteString AudioContent {
      get { return streamingRequestCase_ == StreamingRequestOneofCase.AudioContent ? (pb::ByteString) streamingRequest_ : pb::ByteString.Empty; }
      set {
        streamingRequest_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        streamingRequestCase_ = StreamingRequestOneofCase.AudioContent;
      }
    }

    private object streamingRequest_;
    /// <summary>Enum of possible cases for the "streaming_request" oneof.</summary>
    public enum StreamingRequestOneofCase {
      None = 0,
      StreamingConfig = 1,
      AudioContent = 2,
    }
    private StreamingRequestOneofCase streamingRequestCase_ = StreamingRequestOneofCase.None;
    public StreamingRequestOneofCase StreamingRequestCase {
      get { return streamingRequestCase_; }
    }

    public void ClearStreamingRequest() {
      streamingRequestCase_ = StreamingRequestOneofCase.None;
      streamingRequest_ = null;
    }

    public override bool Equals(object other) {
      return Equals(other as StreamingRecognizeRequest);
    }

    public bool Equals(StreamingRecognizeRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(StreamingConfig, other.StreamingConfig)) return false;
      if (AudioContent != other.AudioContent) return false;
      if (StreamingRequestCase != other.StreamingRequestCase) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (streamingRequestCase_ == StreamingRequestOneofCase.StreamingConfig) hash ^= StreamingConfig.GetHashCode();
      if (streamingRequestCase_ == StreamingRequestOneofCase.AudioContent) hash ^= AudioContent.GetHashCode();
      hash ^= (int) streamingRequestCase_;
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (streamingRequestCase_ == StreamingRequestOneofCase.StreamingConfig) {
        output.WriteRawTag(10);
        output.WriteMessage(StreamingConfig);
      }
      if (streamingRequestCase_ == StreamingRequestOneofCase.AudioContent) {
        output.WriteRawTag(18);
        output.WriteBytes(AudioContent);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (streamingRequestCase_ == StreamingRequestOneofCase.StreamingConfig) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StreamingConfig);
      }
      if (streamingRequestCase_ == StreamingRequestOneofCase.AudioContent) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(AudioContent);
      }
      return size;
    }

    public void MergeFrom(StreamingRecognizeRequest other) {
      if (other == null) {
        return;
      }
      switch (other.StreamingRequestCase) {
        case StreamingRequestOneofCase.StreamingConfig:
          StreamingConfig = other.StreamingConfig;
          break;
        case StreamingRequestOneofCase.AudioContent:
          AudioContent = other.AudioContent;
          break;
      }

    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            global::Google.Cloud.Speech.V1Beta1.StreamingRecognitionConfig subBuilder = new global::Google.Cloud.Speech.V1Beta1.StreamingRecognitionConfig();
            if (streamingRequestCase_ == StreamingRequestOneofCase.StreamingConfig) {
              subBuilder.MergeFrom(StreamingConfig);
            }
            input.ReadMessage(subBuilder);
            StreamingConfig = subBuilder;
            break;
          }
          case 18: {
            AudioContent = input.ReadBytes();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  The `StreamingRecognitionConfig` message provides information to the
  ///  recognizer that specifies how to process the request.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class StreamingRecognitionConfig : pb::IMessage<StreamingRecognitionConfig> {
    private static readonly pb::MessageParser<StreamingRecognitionConfig> _parser = new pb::MessageParser<StreamingRecognitionConfig>(() => new StreamingRecognitionConfig());
    public static pb::MessageParser<StreamingRecognitionConfig> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Speech.V1Beta1.CloudSpeechReflection.Descriptor.MessageTypes[3]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public StreamingRecognitionConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    public StreamingRecognitionConfig(StreamingRecognitionConfig other) : this() {
      Config = other.config_ != null ? other.Config.Clone() : null;
      singleUtterance_ = other.singleUtterance_;
      interimResults_ = other.interimResults_;
    }

    public StreamingRecognitionConfig Clone() {
      return new StreamingRecognitionConfig(this);
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 1;
    private global::Google.Cloud.Speech.V1Beta1.RecognitionConfig config_;
    /// <summary>
    ///  [Required] The `config` message provides information to the recognizer
    ///  that specifies how to process the request.
    /// </summary>
    public global::Google.Cloud.Speech.V1Beta1.RecognitionConfig Config {
      get { return config_; }
      set {
        config_ = value;
      }
    }

    /// <summary>Field number for the "single_utterance" field.</summary>
    public const int SingleUtteranceFieldNumber = 2;
    private bool singleUtterance_;
    /// <summary>
    ///  [Optional] If `false` or omitted, the recognizer will perform continuous
    ///  recognition (continuing to process audio even if the user pauses speaking)
    ///  until the client closes the output stream (gRPC API) or when the maximum
    ///  time limit has been reached. Multiple `SpeechRecognitionResult`s with the
    ///  `is_final` flag set to `true` may be returned.
    ///
    ///  If `true`, the recognizer will detect a single spoken utterance. When it
    ///  detects that the user has paused or stopped speaking, it will return an
    ///  `END_OF_UTTERANCE` event and cease recognition. It will return no more than
    ///  one `SpeechRecognitionResult` with the `is_final` flag set to `true`.
    /// </summary>
    public bool SingleUtterance {
      get { return singleUtterance_; }
      set {
        singleUtterance_ = value;
      }
    }

    /// <summary>Field number for the "interim_results" field.</summary>
    public const int InterimResultsFieldNumber = 3;
    private bool interimResults_;
    /// <summary>
    ///  [Optional] If `true`, interim results (tentative hypotheses) may be
    ///  returned as they become available (these interim results are indicated with
    ///  the `is_final=false` flag).
    ///  If `false` or omitted, only `is_final=true` result(s) are returned.
    /// </summary>
    public bool InterimResults {
      get { return interimResults_; }
      set {
        interimResults_ = value;
      }
    }

    public override bool Equals(object other) {
      return Equals(other as StreamingRecognitionConfig);
    }

    public bool Equals(StreamingRecognitionConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Config, other.Config)) return false;
      if (SingleUtterance != other.SingleUtterance) return false;
      if (InterimResults != other.InterimResults) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (config_ != null) hash ^= Config.GetHashCode();
      if (SingleUtterance != false) hash ^= SingleUtterance.GetHashCode();
      if (InterimResults != false) hash ^= InterimResults.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (config_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Config);
      }
      if (SingleUtterance != false) {
        output.WriteRawTag(16);
        output.WriteBool(SingleUtterance);
      }
      if (InterimResults != false) {
        output.WriteRawTag(24);
        output.WriteBool(InterimResults);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (config_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      if (SingleUtterance != false) {
        size += 1 + 1;
      }
      if (InterimResults != false) {
        size += 1 + 1;
      }
      return size;
    }

    public void MergeFrom(StreamingRecognitionConfig other) {
      if (other == null) {
        return;
      }
      if (other.config_ != null) {
        if (config_ == null) {
          config_ = new global::Google.Cloud.Speech.V1Beta1.RecognitionConfig();
        }
        Config.MergeFrom(other.Config);
      }
      if (other.SingleUtterance != false) {
        SingleUtterance = other.SingleUtterance;
      }
      if (other.InterimResults != false) {
        InterimResults = other.InterimResults;
      }
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (config_ == null) {
              config_ = new global::Google.Cloud.Speech.V1Beta1.RecognitionConfig();
            }
            input.ReadMessage(config_);
            break;
          }
          case 16: {
            SingleUtterance = input.ReadBool();
            break;
          }
          case 24: {
            InterimResults = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  The `RecognitionConfig` message provides information to the recognizer
  ///  that specifies how to process the request.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class RecognitionConfig : pb::IMessage<RecognitionConfig> {
    private static readonly pb::MessageParser<RecognitionConfig> _parser = new pb::MessageParser<RecognitionConfig>(() => new RecognitionConfig());
    public static pb::MessageParser<RecognitionConfig> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Speech.V1Beta1.CloudSpeechReflection.Descriptor.MessageTypes[4]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public RecognitionConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    public RecognitionConfig(RecognitionConfig other) : this() {
      encoding_ = other.encoding_;
      sampleRate_ = other.sampleRate_;
      languageCode_ = other.languageCode_;
      maxAlternatives_ = other.maxAlternatives_;
      profanityFilter_ = other.profanityFilter_;
      SpeechContext = other.speechContext_ != null ? other.SpeechContext.Clone() : null;
    }

    public RecognitionConfig Clone() {
      return new RecognitionConfig(this);
    }

    /// <summary>Field number for the "encoding" field.</summary>
    public const int EncodingFieldNumber = 1;
    private global::Google.Cloud.Speech.V1Beta1.RecognitionConfig.Types.AudioEncoding encoding_ = global::Google.Cloud.Speech.V1Beta1.RecognitionConfig.Types.AudioEncoding.ENCODING_UNSPECIFIED;
    /// <summary>
    ///  [Required] Encoding of audio data sent in all `RecognitionAudio` messages.
    /// </summary>
    public global::Google.Cloud.Speech.V1Beta1.RecognitionConfig.Types.AudioEncoding Encoding {
      get { return encoding_; }
      set {
        encoding_ = value;
      }
    }

    /// <summary>Field number for the "sample_rate" field.</summary>
    public const int SampleRateFieldNumber = 2;
    private int sampleRate_;
    /// <summary>
    ///  [Required] Sample rate in Hertz of the audio data sent in all
    ///  `RecognitionAudio` messages. Valid values are: 8000-48000.
    ///  16000 is optimal. For best results, set the sampling rate of the audio
    ///  source to 16000 Hz. If that's not possible, use the native sample rate of
    ///  the audio source (instead of re-sampling).
    /// </summary>
    public int SampleRate {
      get { return sampleRate_; }
      set {
        sampleRate_ = value;
      }
    }

    /// <summary>Field number for the "language_code" field.</summary>
    public const int LanguageCodeFieldNumber = 3;
    private string languageCode_ = "";
    /// <summary>
    ///  [Optional] The language of the supplied audio as a BCP-47 language tag.
    ///  Example: "en-GB"  https://www.rfc-editor.org/rfc/bcp/bcp47.txt
    ///  If omitted, defaults to "en-US". See
    ///  [Language Support](/speech/docs/best-practices#language_support) for
    ///  a list of the currently supported language codes.
    /// </summary>
    public string LanguageCode {
      get { return languageCode_; }
      set {
        languageCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "max_alternatives" field.</summary>
    public const int MaxAlternativesFieldNumber = 4;
    private int maxAlternatives_;
    /// <summary>
    ///  [Optional] Maximum number of recognition hypotheses to be returned.
    ///  Specifically, the maximum number of `SpeechRecognitionAlternative` messages
    ///  within each `SpeechRecognitionResult`.
    ///  The server may return fewer than `max_alternatives`.
    ///  Valid values are `0`-`30`. A value of `0` or `1` will return a maximum of
    ///  `1`. If omitted, defaults to `1`.
    /// </summary>
    public int MaxAlternatives {
      get { return maxAlternatives_; }
      set {
        maxAlternatives_ = value;
      }
    }

    /// <summary>Field number for the "profanity_filter" field.</summary>
    public const int ProfanityFilterFieldNumber = 5;
    private bool profanityFilter_;
    /// <summary>
    ///  [Optional] If set to `true`, the server will attempt to filter out
    ///  profanities, replacing all but the initial character in each filtered word
    ///  with asterisks, e.g. "f***". If set to `false` or omitted, profanities
    ///  won't be filtered out.
    /// </summary>
    public bool ProfanityFilter {
      get { return profanityFilter_; }
      set {
        profanityFilter_ = value;
      }
    }

    /// <summary>Field number for the "speech_context" field.</summary>
    public const int SpeechContextFieldNumber = 6;
    private global::Google.Cloud.Speech.V1Beta1.SpeechContext speechContext_;
    /// <summary>
    ///  [Optional] A means to provide context to assist the speech recognition.
    /// </summary>
    public global::Google.Cloud.Speech.V1Beta1.SpeechContext SpeechContext {
      get { return speechContext_; }
      set {
        speechContext_ = value;
      }
    }

    public override bool Equals(object other) {
      return Equals(other as RecognitionConfig);
    }

    public bool Equals(RecognitionConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Encoding != other.Encoding) return false;
      if (SampleRate != other.SampleRate) return false;
      if (LanguageCode != other.LanguageCode) return false;
      if (MaxAlternatives != other.MaxAlternatives) return false;
      if (ProfanityFilter != other.ProfanityFilter) return false;
      if (!object.Equals(SpeechContext, other.SpeechContext)) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Encoding != global::Google.Cloud.Speech.V1Beta1.RecognitionConfig.Types.AudioEncoding.ENCODING_UNSPECIFIED) hash ^= Encoding.GetHashCode();
      if (SampleRate != 0) hash ^= SampleRate.GetHashCode();
      if (LanguageCode.Length != 0) hash ^= LanguageCode.GetHashCode();
      if (MaxAlternatives != 0) hash ^= MaxAlternatives.GetHashCode();
      if (ProfanityFilter != false) hash ^= ProfanityFilter.GetHashCode();
      if (speechContext_ != null) hash ^= SpeechContext.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Encoding != global::Google.Cloud.Speech.V1Beta1.RecognitionConfig.Types.AudioEncoding.ENCODING_UNSPECIFIED) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Encoding);
      }
      if (SampleRate != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(SampleRate);
      }
      if (LanguageCode.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(LanguageCode);
      }
      if (MaxAlternatives != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(MaxAlternatives);
      }
      if (ProfanityFilter != false) {
        output.WriteRawTag(40);
        output.WriteBool(ProfanityFilter);
      }
      if (speechContext_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(SpeechContext);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Encoding != global::Google.Cloud.Speech.V1Beta1.RecognitionConfig.Types.AudioEncoding.ENCODING_UNSPECIFIED) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Encoding);
      }
      if (SampleRate != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SampleRate);
      }
      if (LanguageCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LanguageCode);
      }
      if (MaxAlternatives != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxAlternatives);
      }
      if (ProfanityFilter != false) {
        size += 1 + 1;
      }
      if (speechContext_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SpeechContext);
      }
      return size;
    }

    public void MergeFrom(RecognitionConfig other) {
      if (other == null) {
        return;
      }
      if (other.Encoding != global::Google.Cloud.Speech.V1Beta1.RecognitionConfig.Types.AudioEncoding.ENCODING_UNSPECIFIED) {
        Encoding = other.Encoding;
      }
      if (other.SampleRate != 0) {
        SampleRate = other.SampleRate;
      }
      if (other.LanguageCode.Length != 0) {
        LanguageCode = other.LanguageCode;
      }
      if (other.MaxAlternatives != 0) {
        MaxAlternatives = other.MaxAlternatives;
      }
      if (other.ProfanityFilter != false) {
        ProfanityFilter = other.ProfanityFilter;
      }
      if (other.speechContext_ != null) {
        if (speechContext_ == null) {
          speechContext_ = new global::Google.Cloud.Speech.V1Beta1.SpeechContext();
        }
        SpeechContext.MergeFrom(other.SpeechContext);
      }
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            encoding_ = (global::Google.Cloud.Speech.V1Beta1.RecognitionConfig.Types.AudioEncoding) input.ReadEnum();
            break;
          }
          case 16: {
            SampleRate = input.ReadInt32();
            break;
          }
          case 26: {
            LanguageCode = input.ReadString();
            break;
          }
          case 32: {
            MaxAlternatives = input.ReadInt32();
            break;
          }
          case 40: {
            ProfanityFilter = input.ReadBool();
            break;
          }
          case 50: {
            if (speechContext_ == null) {
              speechContext_ = new global::Google.Cloud.Speech.V1Beta1.SpeechContext();
            }
            input.ReadMessage(speechContext_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RecognitionConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      /// <summary>
      ///  Audio encoding of the data sent in the audio message. All encodings support
      ///  only 1 channel (mono) audio. Only `FLAC` includes a header that describes
      ///  the bytes of audio that follow the header. The other encodings are raw
      ///  audio bytes with no header.
      ///
      ///  For best results, the audio source should be captured and transmitted using
      ///  a lossless encoding (`FLAC` or `LINEAR16`). Recognition accuracy may be
      ///  reduced if lossy codecs (such as AMR, AMR_WB and MULAW) are used to capture
      ///  or transmit the audio, particularly if background noise is present.
      /// </summary>
      public enum AudioEncoding {
        /// <summary>
        ///  Not specified. Will return result [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT].
        /// </summary>
        ENCODING_UNSPECIFIED = 0,
        /// <summary>
        ///  Uncompressed 16-bit signed little-endian samples.
        ///  This is the only encoding that may be used by `AsyncRecognize`.
        /// </summary>
        LINEAR16 = 1,
        /// <summary>
        ///  This is the recommended encoding for `SyncRecognize` and
        ///  `StreamingRecognize` because it uses lossless compression; therefore
        ///  recognition accuracy is not compromised by a lossy codec.
        ///
        ///  The stream FLAC (Free Lossless Audio Codec) encoding is specified at:
        ///  http://flac.sourceforge.net/documentation.html.
        ///  Only 16-bit samples are supported.
        ///  Not all fields in STREAMINFO are supported.
        /// </summary>
        FLAC = 2,
        /// <summary>
        ///  8-bit samples that compand 14-bit audio samples using G.711 PCMU/mu-law.
        /// </summary>
        MULAW = 3,
        /// <summary>
        ///  Adaptive Multi-Rate Narrowband codec. `sample_rate` must be 8000 Hz.
        /// </summary>
        AMR = 4,
        /// <summary>
        ///  Adaptive Multi-Rate Wideband codec. `sample_rate` must be 16000 Hz.
        /// </summary>
        AMR_WB = 5,
      }

    }
    #endregion

  }

  /// <summary>
  ///  Provides "hints" to the speech recognizer to favor specific words and phrases
  ///  in the results.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class SpeechContext : pb::IMessage<SpeechContext> {
    private static readonly pb::MessageParser<SpeechContext> _parser = new pb::MessageParser<SpeechContext>(() => new SpeechContext());
    public static pb::MessageParser<SpeechContext> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Speech.V1Beta1.CloudSpeechReflection.Descriptor.MessageTypes[5]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public SpeechContext() {
      OnConstruction();
    }

    partial void OnConstruction();

    public SpeechContext(SpeechContext other) : this() {
      phrases_ = other.phrases_.Clone();
    }

    public SpeechContext Clone() {
      return new SpeechContext(this);
    }

    /// <summary>Field number for the "phrases" field.</summary>
    public const int PhrasesFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_phrases_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> phrases_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///  [Optional] A list of up to 50 phrases of up to 100 characters each to
    ///  provide words and phrases "hints" to the speech recognition so that it is
    ///  more likely to recognize them.
    /// </summary>
    public pbc::RepeatedField<string> Phrases {
      get { return phrases_; }
    }

    public override bool Equals(object other) {
      return Equals(other as SpeechContext);
    }

    public bool Equals(SpeechContext other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!phrases_.Equals(other.phrases_)) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= phrases_.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      phrases_.WriteTo(output, _repeated_phrases_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += phrases_.CalculateSize(_repeated_phrases_codec);
      return size;
    }

    public void MergeFrom(SpeechContext other) {
      if (other == null) {
        return;
      }
      phrases_.Add(other.phrases_);
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            phrases_.AddEntriesFrom(input, _repeated_phrases_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Contains audio data in the encoding specified in the `RecognitionConfig`.
  ///  Either `content` or `uri` must be supplied. Supplying both or neither
  ///  returns [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT].
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class RecognitionAudio : pb::IMessage<RecognitionAudio> {
    private static readonly pb::MessageParser<RecognitionAudio> _parser = new pb::MessageParser<RecognitionAudio>(() => new RecognitionAudio());
    public static pb::MessageParser<RecognitionAudio> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Speech.V1Beta1.CloudSpeechReflection.Descriptor.MessageTypes[6]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public RecognitionAudio() {
      OnConstruction();
    }

    partial void OnConstruction();

    public RecognitionAudio(RecognitionAudio other) : this() {
      switch (other.AudioSourceCase) {
        case AudioSourceOneofCase.Content:
          Content = other.Content;
          break;
        case AudioSourceOneofCase.Uri:
          Uri = other.Uri;
          break;
      }

    }

    public RecognitionAudio Clone() {
      return new RecognitionAudio(this);
    }

    /// <summary>Field number for the "content" field.</summary>
    public const int ContentFieldNumber = 1;
    /// <summary>
    ///  The audio data bytes encoded as specified in
    ///  `RecognitionConfig`. Note: as with all bytes fields, protobuffers use a
    ///  pure binary representation, whereas JSON representations use base64.
    /// </summary>
    public pb::ByteString Content {
      get { return audioSourceCase_ == AudioSourceOneofCase.Content ? (pb::ByteString) audioSource_ : pb::ByteString.Empty; }
      set {
        audioSource_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        audioSourceCase_ = AudioSourceOneofCase.Content;
      }
    }

    /// <summary>Field number for the "uri" field.</summary>
    public const int UriFieldNumber = 2;
    /// <summary>
    ///  URI that points to a file that contains audio data bytes as specified in
    ///  `RecognitionConfig`. Currently, only Google Cloud Storage URIs are
    ///  supported, which must be specified in the following format:
    ///  `gs://bucket_name/object_name` (other URI formats return
    ///  [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]). For more information, see
    ///  [Request URIs](/storage/docs/reference-uris).
    /// </summary>
    public string Uri {
      get { return audioSourceCase_ == AudioSourceOneofCase.Uri ? (string) audioSource_ : ""; }
      set {
        audioSource_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        audioSourceCase_ = AudioSourceOneofCase.Uri;
      }
    }

    private object audioSource_;
    /// <summary>Enum of possible cases for the "audio_source" oneof.</summary>
    public enum AudioSourceOneofCase {
      None = 0,
      Content = 1,
      Uri = 2,
    }
    private AudioSourceOneofCase audioSourceCase_ = AudioSourceOneofCase.None;
    public AudioSourceOneofCase AudioSourceCase {
      get { return audioSourceCase_; }
    }

    public void ClearAudioSource() {
      audioSourceCase_ = AudioSourceOneofCase.None;
      audioSource_ = null;
    }

    public override bool Equals(object other) {
      return Equals(other as RecognitionAudio);
    }

    public bool Equals(RecognitionAudio other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Content != other.Content) return false;
      if (Uri != other.Uri) return false;
      if (AudioSourceCase != other.AudioSourceCase) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (audioSourceCase_ == AudioSourceOneofCase.Content) hash ^= Content.GetHashCode();
      if (audioSourceCase_ == AudioSourceOneofCase.Uri) hash ^= Uri.GetHashCode();
      hash ^= (int) audioSourceCase_;
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (audioSourceCase_ == AudioSourceOneofCase.Content) {
        output.WriteRawTag(10);
        output.WriteBytes(Content);
      }
      if (audioSourceCase_ == AudioSourceOneofCase.Uri) {
        output.WriteRawTag(18);
        output.WriteString(Uri);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (audioSourceCase_ == AudioSourceOneofCase.Content) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Content);
      }
      if (audioSourceCase_ == AudioSourceOneofCase.Uri) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Uri);
      }
      return size;
    }

    public void MergeFrom(RecognitionAudio other) {
      if (other == null) {
        return;
      }
      switch (other.AudioSourceCase) {
        case AudioSourceOneofCase.Content:
          Content = other.Content;
          break;
        case AudioSourceOneofCase.Uri:
          Uri = other.Uri;
          break;
      }

    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Content = input.ReadBytes();
            break;
          }
          case 18: {
            Uri = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  `SyncRecognizeResponse` is the only message returned to the client by
  ///  `SyncRecognize`. It contains the result as zero or more
  ///  sequential `RecognizeResponse` messages.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class SyncRecognizeResponse : pb::IMessage<SyncRecognizeResponse> {
    private static readonly pb::MessageParser<SyncRecognizeResponse> _parser = new pb::MessageParser<SyncRecognizeResponse>(() => new SyncRecognizeResponse());
    public static pb::MessageParser<SyncRecognizeResponse> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Speech.V1Beta1.CloudSpeechReflection.Descriptor.MessageTypes[7]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public SyncRecognizeResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    public SyncRecognizeResponse(SyncRecognizeResponse other) : this() {
      results_ = other.results_.Clone();
    }

    public SyncRecognizeResponse Clone() {
      return new SyncRecognizeResponse(this);
    }

    /// <summary>Field number for the "results" field.</summary>
    public const int ResultsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionResult> _repeated_results_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionResult.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionResult> results_ = new pbc::RepeatedField<global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionResult>();
    /// <summary>
    ///  [Output-only] Sequential list of transcription results corresponding to
    ///  sequential portions of audio.
    /// </summary>
    public pbc::RepeatedField<global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionResult> Results {
      get { return results_; }
    }

    public override bool Equals(object other) {
      return Equals(other as SyncRecognizeResponse);
    }

    public bool Equals(SyncRecognizeResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!results_.Equals(other.results_)) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= results_.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      results_.WriteTo(output, _repeated_results_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += results_.CalculateSize(_repeated_results_codec);
      return size;
    }

    public void MergeFrom(SyncRecognizeResponse other) {
      if (other == null) {
        return;
      }
      results_.Add(other.results_);
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 18: {
            results_.AddEntriesFrom(input, _repeated_results_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  `AsyncRecognizeResponse` is the only message returned to the client by
  ///  `AsyncRecognize`. It contains the result as zero or more
  ///  sequential `RecognizeResponse` messages.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class AsyncRecognizeResponse : pb::IMessage<AsyncRecognizeResponse> {
    private static readonly pb::MessageParser<AsyncRecognizeResponse> _parser = new pb::MessageParser<AsyncRecognizeResponse>(() => new AsyncRecognizeResponse());
    public static pb::MessageParser<AsyncRecognizeResponse> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Speech.V1Beta1.CloudSpeechReflection.Descriptor.MessageTypes[8]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public AsyncRecognizeResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    public AsyncRecognizeResponse(AsyncRecognizeResponse other) : this() {
      results_ = other.results_.Clone();
    }

    public AsyncRecognizeResponse Clone() {
      return new AsyncRecognizeResponse(this);
    }

    /// <summary>Field number for the "results" field.</summary>
    public const int ResultsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionResult> _repeated_results_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionResult.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionResult> results_ = new pbc::RepeatedField<global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionResult>();
    /// <summary>
    ///  [Output-only] Sequential list of transcription results corresponding to
    ///  sequential portions of audio.
    /// </summary>
    public pbc::RepeatedField<global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionResult> Results {
      get { return results_; }
    }

    public override bool Equals(object other) {
      return Equals(other as AsyncRecognizeResponse);
    }

    public bool Equals(AsyncRecognizeResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!results_.Equals(other.results_)) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= results_.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      results_.WriteTo(output, _repeated_results_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += results_.CalculateSize(_repeated_results_codec);
      return size;
    }

    public void MergeFrom(AsyncRecognizeResponse other) {
      if (other == null) {
        return;
      }
      results_.Add(other.results_);
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 18: {
            results_.AddEntriesFrom(input, _repeated_results_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  `StreamingRecognizeResponse` is the only message returned to the client by
  ///  `StreamingRecognize`. It contains the result as zero or more
  ///  sequential `RecognizeResponse` messages.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class StreamingRecognizeResponse : pb::IMessage<StreamingRecognizeResponse> {
    private static readonly pb::MessageParser<StreamingRecognizeResponse> _parser = new pb::MessageParser<StreamingRecognizeResponse>(() => new StreamingRecognizeResponse());
    public static pb::MessageParser<StreamingRecognizeResponse> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Speech.V1Beta1.CloudSpeechReflection.Descriptor.MessageTypes[9]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public StreamingRecognizeResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    public StreamingRecognizeResponse(StreamingRecognizeResponse other) : this() {
      Error = other.error_ != null ? other.Error.Clone() : null;
      results_ = other.results_.Clone();
      resultIndex_ = other.resultIndex_;
      endpointerType_ = other.endpointerType_;
    }

    public StreamingRecognizeResponse Clone() {
      return new StreamingRecognizeResponse(this);
    }

    /// <summary>Field number for the "error" field.</summary>
    public const int ErrorFieldNumber = 1;
    private global::Google.Rpc.Status error_;
    /// <summary>
    ///  [Output-only] If set, returns a [google.rpc.Status][] message that
    ///  specifies the error for the operation.
    /// </summary>
    public global::Google.Rpc.Status Error {
      get { return error_; }
      set {
        error_ = value;
      }
    }

    /// <summary>Field number for the "results" field.</summary>
    public const int ResultsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Cloud.Speech.V1Beta1.StreamingRecognitionResult> _repeated_results_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Cloud.Speech.V1Beta1.StreamingRecognitionResult.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Speech.V1Beta1.StreamingRecognitionResult> results_ = new pbc::RepeatedField<global::Google.Cloud.Speech.V1Beta1.StreamingRecognitionResult>();
    /// <summary>
    ///  [Output-only] This repeated list contains zero or more results that
    ///  correspond to consecutive portions of the audio currently being processed.
    ///  It contains zero or one `is_final=true` result (the newly settled portion),
    ///  followed by zero or more `is_final=false` results.
    /// </summary>
    public pbc::RepeatedField<global::Google.Cloud.Speech.V1Beta1.StreamingRecognitionResult> Results {
      get { return results_; }
    }

    /// <summary>Field number for the "result_index" field.</summary>
    public const int ResultIndexFieldNumber = 3;
    private int resultIndex_;
    /// <summary>
    ///  [Output-only] Indicates the lowest index in the `results` array that has
    ///  changed. The repeated `SpeechRecognitionResult` results overwrite past
    ///  results at this index and higher.
    /// </summary>
    public int ResultIndex {
      get { return resultIndex_; }
      set {
        resultIndex_ = value;
      }
    }

    /// <summary>Field number for the "endpointer_type" field.</summary>
    public const int EndpointerTypeFieldNumber = 4;
    private global::Google.Cloud.Speech.V1Beta1.StreamingRecognizeResponse.Types.EndpointerType endpointerType_ = global::Google.Cloud.Speech.V1Beta1.StreamingRecognizeResponse.Types.EndpointerType.ENDPOINTER_EVENT_UNSPECIFIED;
    /// <summary>
    ///  [Output-only] Indicates the type of endpointer event.
    /// </summary>
    public global::Google.Cloud.Speech.V1Beta1.StreamingRecognizeResponse.Types.EndpointerType EndpointerType {
      get { return endpointerType_; }
      set {
        endpointerType_ = value;
      }
    }

    public override bool Equals(object other) {
      return Equals(other as StreamingRecognizeResponse);
    }

    public bool Equals(StreamingRecognizeResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Error, other.Error)) return false;
      if(!results_.Equals(other.results_)) return false;
      if (ResultIndex != other.ResultIndex) return false;
      if (EndpointerType != other.EndpointerType) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (error_ != null) hash ^= Error.GetHashCode();
      hash ^= results_.GetHashCode();
      if (ResultIndex != 0) hash ^= ResultIndex.GetHashCode();
      if (EndpointerType != global::Google.Cloud.Speech.V1Beta1.StreamingRecognizeResponse.Types.EndpointerType.ENDPOINTER_EVENT_UNSPECIFIED) hash ^= EndpointerType.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (error_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Error);
      }
      results_.WriteTo(output, _repeated_results_codec);
      if (ResultIndex != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(ResultIndex);
      }
      if (EndpointerType != global::Google.Cloud.Speech.V1Beta1.StreamingRecognizeResponse.Types.EndpointerType.ENDPOINTER_EVENT_UNSPECIFIED) {
        output.WriteRawTag(32);
        output.WriteEnum((int) EndpointerType);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (error_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Error);
      }
      size += results_.CalculateSize(_repeated_results_codec);
      if (ResultIndex != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ResultIndex);
      }
      if (EndpointerType != global::Google.Cloud.Speech.V1Beta1.StreamingRecognizeResponse.Types.EndpointerType.ENDPOINTER_EVENT_UNSPECIFIED) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) EndpointerType);
      }
      return size;
    }

    public void MergeFrom(StreamingRecognizeResponse other) {
      if (other == null) {
        return;
      }
      if (other.error_ != null) {
        if (error_ == null) {
          error_ = new global::Google.Rpc.Status();
        }
        Error.MergeFrom(other.Error);
      }
      results_.Add(other.results_);
      if (other.ResultIndex != 0) {
        ResultIndex = other.ResultIndex;
      }
      if (other.EndpointerType != global::Google.Cloud.Speech.V1Beta1.StreamingRecognizeResponse.Types.EndpointerType.ENDPOINTER_EVENT_UNSPECIFIED) {
        EndpointerType = other.EndpointerType;
      }
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (error_ == null) {
              error_ = new global::Google.Rpc.Status();
            }
            input.ReadMessage(error_);
            break;
          }
          case 18: {
            results_.AddEntriesFrom(input, _repeated_results_codec);
            break;
          }
          case 24: {
            ResultIndex = input.ReadInt32();
            break;
          }
          case 32: {
            endpointerType_ = (global::Google.Cloud.Speech.V1Beta1.StreamingRecognizeResponse.Types.EndpointerType) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the StreamingRecognizeResponse message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      /// <summary>
      ///  Indicates the type of endpointer event.
      /// </summary>
      public enum EndpointerType {
        /// <summary>
        ///  No endpointer event specified.
        /// </summary>
        ENDPOINTER_EVENT_UNSPECIFIED = 0,
        /// <summary>
        ///  Speech has been detected in the audio stream.
        /// </summary>
        START_OF_SPEECH = 1,
        /// <summary>
        ///  Speech has ceased to be detected in the audio stream.
        /// </summary>
        END_OF_SPEECH = 2,
        /// <summary>
        ///  The end of the audio stream has been reached. and it is being processed.
        /// </summary>
        END_OF_AUDIO = 3,
        /// <summary>
        ///  This event is only sent when `single_utterance` is `true`. It indicates
        ///  that the server has detected the end of the user's speech utterance and
        ///  expects no additional speech. Therefore, the server will not process
        ///  additional audio. The client should stop sending additional audio data.
        /// </summary>
        END_OF_UTTERANCE = 4,
      }

    }
    #endregion

  }

  /// <summary>
  ///  A speech recognition result corresponding to a portion of the audio that is
  ///  currently being processed.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class StreamingRecognitionResult : pb::IMessage<StreamingRecognitionResult> {
    private static readonly pb::MessageParser<StreamingRecognitionResult> _parser = new pb::MessageParser<StreamingRecognitionResult>(() => new StreamingRecognitionResult());
    public static pb::MessageParser<StreamingRecognitionResult> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Speech.V1Beta1.CloudSpeechReflection.Descriptor.MessageTypes[10]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public StreamingRecognitionResult() {
      OnConstruction();
    }

    partial void OnConstruction();

    public StreamingRecognitionResult(StreamingRecognitionResult other) : this() {
      alternatives_ = other.alternatives_.Clone();
      isFinal_ = other.isFinal_;
      stability_ = other.stability_;
    }

    public StreamingRecognitionResult Clone() {
      return new StreamingRecognitionResult(this);
    }

    /// <summary>Field number for the "alternatives" field.</summary>
    public const int AlternativesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionAlternative> _repeated_alternatives_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionAlternative.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionAlternative> alternatives_ = new pbc::RepeatedField<global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionAlternative>();
    /// <summary>
    ///  [Output-only] May contain one or more recognition hypotheses (up to the
    ///  maximum specified in `max_alternatives`).
    /// </summary>
    public pbc::RepeatedField<global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionAlternative> Alternatives {
      get { return alternatives_; }
    }

    /// <summary>Field number for the "is_final" field.</summary>
    public const int IsFinalFieldNumber = 2;
    private bool isFinal_;
    /// <summary>
    ///  [Output-only] If `false`, this `SpeechRecognitionResult` represents an
    ///  interim result that may change. If `true`, this is the final time the
    ///  speech service will return this particular `SpeechRecognitionResult`,
    ///  the recognizer will not return any further hypotheses for this portion of
    ///  the transcript and corresponding audio.
    /// </summary>
    public bool IsFinal {
      get { return isFinal_; }
      set {
        isFinal_ = value;
      }
    }

    /// <summary>Field number for the "stability" field.</summary>
    public const int StabilityFieldNumber = 3;
    private float stability_;
    /// <summary>
    ///  [Output-only] An estimate of the probability that the recognizer will not
    ///  change its guess about this interim result. Values range from 0.0
    ///  (completely unstable) to 1.0 (completely stable). Note that this is not the
    ///  same as `confidence`, which estimates the probability that a recognition
    ///  result is correct.
    ///  This field is only provided for interim results (`is_final=false`).
    ///  The default of 0.0 is a sentinel value indicating stability was not set.
    /// </summary>
    public float Stability {
      get { return stability_; }
      set {
        stability_ = value;
      }
    }

    public override bool Equals(object other) {
      return Equals(other as StreamingRecognitionResult);
    }

    public bool Equals(StreamingRecognitionResult other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!alternatives_.Equals(other.alternatives_)) return false;
      if (IsFinal != other.IsFinal) return false;
      if (Stability != other.Stability) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= alternatives_.GetHashCode();
      if (IsFinal != false) hash ^= IsFinal.GetHashCode();
      if (Stability != 0F) hash ^= Stability.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      alternatives_.WriteTo(output, _repeated_alternatives_codec);
      if (IsFinal != false) {
        output.WriteRawTag(16);
        output.WriteBool(IsFinal);
      }
      if (Stability != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(Stability);
      }
    }

    public int CalculateSize() {
      int size = 0;
      size += alternatives_.CalculateSize(_repeated_alternatives_codec);
      if (IsFinal != false) {
        size += 1 + 1;
      }
      if (Stability != 0F) {
        size += 1 + 4;
      }
      return size;
    }

    public void MergeFrom(StreamingRecognitionResult other) {
      if (other == null) {
        return;
      }
      alternatives_.Add(other.alternatives_);
      if (other.IsFinal != false) {
        IsFinal = other.IsFinal;
      }
      if (other.Stability != 0F) {
        Stability = other.Stability;
      }
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            alternatives_.AddEntriesFrom(input, _repeated_alternatives_codec);
            break;
          }
          case 16: {
            IsFinal = input.ReadBool();
            break;
          }
          case 29: {
            Stability = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  A speech recognition result corresponding to a portion of the audio.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class SpeechRecognitionResult : pb::IMessage<SpeechRecognitionResult> {
    private static readonly pb::MessageParser<SpeechRecognitionResult> _parser = new pb::MessageParser<SpeechRecognitionResult>(() => new SpeechRecognitionResult());
    public static pb::MessageParser<SpeechRecognitionResult> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Speech.V1Beta1.CloudSpeechReflection.Descriptor.MessageTypes[11]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public SpeechRecognitionResult() {
      OnConstruction();
    }

    partial void OnConstruction();

    public SpeechRecognitionResult(SpeechRecognitionResult other) : this() {
      alternatives_ = other.alternatives_.Clone();
    }

    public SpeechRecognitionResult Clone() {
      return new SpeechRecognitionResult(this);
    }

    /// <summary>Field number for the "alternatives" field.</summary>
    public const int AlternativesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionAlternative> _repeated_alternatives_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionAlternative.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionAlternative> alternatives_ = new pbc::RepeatedField<global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionAlternative>();
    /// <summary>
    ///  [Output-only] May contain one or more recognition hypotheses (up to the
    ///  maximum specified in `max_alternatives`).
    /// </summary>
    public pbc::RepeatedField<global::Google.Cloud.Speech.V1Beta1.SpeechRecognitionAlternative> Alternatives {
      get { return alternatives_; }
    }

    public override bool Equals(object other) {
      return Equals(other as SpeechRecognitionResult);
    }

    public bool Equals(SpeechRecognitionResult other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!alternatives_.Equals(other.alternatives_)) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= alternatives_.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      alternatives_.WriteTo(output, _repeated_alternatives_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += alternatives_.CalculateSize(_repeated_alternatives_codec);
      return size;
    }

    public void MergeFrom(SpeechRecognitionResult other) {
      if (other == null) {
        return;
      }
      alternatives_.Add(other.alternatives_);
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            alternatives_.AddEntriesFrom(input, _repeated_alternatives_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Alternative hypotheses (a.k.a. n-best list).
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class SpeechRecognitionAlternative : pb::IMessage<SpeechRecognitionAlternative> {
    private static readonly pb::MessageParser<SpeechRecognitionAlternative> _parser = new pb::MessageParser<SpeechRecognitionAlternative>(() => new SpeechRecognitionAlternative());
    public static pb::MessageParser<SpeechRecognitionAlternative> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Speech.V1Beta1.CloudSpeechReflection.Descriptor.MessageTypes[12]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public SpeechRecognitionAlternative() {
      OnConstruction();
    }

    partial void OnConstruction();

    public SpeechRecognitionAlternative(SpeechRecognitionAlternative other) : this() {
      transcript_ = other.transcript_;
      confidence_ = other.confidence_;
    }

    public SpeechRecognitionAlternative Clone() {
      return new SpeechRecognitionAlternative(this);
    }

    /// <summary>Field number for the "transcript" field.</summary>
    public const int TranscriptFieldNumber = 1;
    private string transcript_ = "";
    /// <summary>
    ///  [Output-only] Transcript text representing the words that the user spoke.
    /// </summary>
    public string Transcript {
      get { return transcript_; }
      set {
        transcript_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "confidence" field.</summary>
    public const int ConfidenceFieldNumber = 2;
    private float confidence_;
    /// <summary>
    ///  [Output-only] The confidence estimate between 0.0 and 1.0. A higher number
    ///  means the system is more confident that the recognition is correct.
    ///  This field is typically provided only for the top hypothesis, and only for
    ///  `is_final=true` results.
    ///  The default of 0.0 is a sentinel value indicating confidence was not set.
    /// </summary>
    public float Confidence {
      get { return confidence_; }
      set {
        confidence_ = value;
      }
    }

    public override bool Equals(object other) {
      return Equals(other as SpeechRecognitionAlternative);
    }

    public bool Equals(SpeechRecognitionAlternative other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Transcript != other.Transcript) return false;
      if (Confidence != other.Confidence) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Transcript.Length != 0) hash ^= Transcript.GetHashCode();
      if (Confidence != 0F) hash ^= Confidence.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Transcript.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Transcript);
      }
      if (Confidence != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(Confidence);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Transcript.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Transcript);
      }
      if (Confidence != 0F) {
        size += 1 + 4;
      }
      return size;
    }

    public void MergeFrom(SpeechRecognitionAlternative other) {
      if (other == null) {
        return;
      }
      if (other.Transcript.Length != 0) {
        Transcript = other.Transcript;
      }
      if (other.Confidence != 0F) {
        Confidence = other.Confidence;
      }
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Transcript = input.ReadString();
            break;
          }
          case 21: {
            Confidence = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
